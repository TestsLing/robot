import re
import json
import time
import chess
import boto3
import random

from botocore.exceptions import ClientError
from aws_lambda_powertools import Logger

logger = Logger()

bedrock_runtime = boto3.client("bedrock-runtime")


def generate_justification(board: chess.Board, move: str) -> str:

    current_fen = board.fen()
    color_indicator = current_fen.split()[1]
    # Convert 'w' or 'b' to full word
    next_move_color = "WHITE" if color_indicator == "w" else "BLACK"

    system_prompt = "You are a chess commentator providing concise justifications for moves. Analyze moves based on the current board position (FEN) and active color. Do not restate the board in the response."

    user_message = {
        "role": "user",
        "content": f"Why is {move} a strong move for {next_move_color} in this position: {board.fen()}? (Max 50 words)",
    }

    messages = [user_message]

    body = json.dumps(
        {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 200,
            "system": system_prompt,
            "messages": messages,
        }
    )
    response = bedrock_runtime.invoke_model(
        body=body, modelId="anthropic.claude-3-5-sonnet-20241022-v2:0"
    )
    response_body = json.loads(response.get("body").read())
    justification = (
        response_body["content"][0]["text"].replace("\n", "").replace('"', "")
    )
    print(f"Justification generated by helper:  {justification}")
    return justification


def custom_model(board, model_id, tries, message_attempts):

    current_fen = board.fen()
    color_indicator = current_fen.split()[1]
    print(f"FEN inside custom model {current_fen}")
    # Convert 'w' or 'b' to full word
    nxt_color = "WHITE" if color_indicator == "w" else "BLACK"

    # prompt = f"You are chess player playing a game of chess. The current Forsyth-Edwards Notation (FEN) of the chess board is {board.fen()}. Generate the next valid move in Standard Algebraic Notation (SAN) to win the game of chess. Provide the move in <move></move> XML tags and provide a short justification, 50 words or less, as to why you believe this is the best move in <reason></reason> XML tags."
    prompt = (
        "You are a chess player who's goal is to win the game, given a chess position in FEN notation and the color to move, "
        "provide the next best valid move in SAN (Standard Algebraic Notation) format to progress towards winning the game of chess. "
        "Your response must be a single move wrapped in <move></move> tags.\n\n"
        f"Chess Position (FEN): {current_fen}\n"
        f"Color to Move: {nxt_color}"
    )

    print(f"Prompt sent:{prompt}")
    request_body = {
        "prompt": prompt,
        "max_tokens": 200,
        "temperature": 0.1,
        "top_p": 0.9,
    }

    print(f"Request Body:{request_body}")
    print(f"Request in JSON{json.dumps(request_body)}")

    response = bedrock_runtime.invoke_model(
        modelId=model_id, body=json.dumps(request_body)
    )

    print(f"RAW CMI RESPONSE{response}")
    response_body = json.loads(response["body"].read().decode())
    generated_text = response_body["generation"]

    print(f"Response Received: {response_body}")
    print(f"Generated Text: {generated_text}")

    # Find the Response section from generated text
    response_section = generated_text.split("### Response:")[-1]

    # Extract move and reason from XML tags

    move_match = re.search(r"<move>(.*?)</move>", response_section)
    reason_match = re.search(r"<reason>(.*?)</reason>", response_section)

    next_move = move_match.group(1) if move_match else ""
    justification = reason_match.group(1) if reason_match else ""

    print(f"Next Move {next_move}")
    print(f"Justification {justification}")
    return (next_move, justification, [])
